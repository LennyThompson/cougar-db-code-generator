// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'template_output.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TemplateOutput _$TemplateOutputFromJson(Map<String, dynamic> json) {
  return _TemplateOutput.fromJson(json);
}

/// @nodoc
mixin _$TemplateOutput {
  @JsonKey(name: 'template')
  String? get template => throw _privateConstructorUsedError;
  @JsonKey(name: 'file-extension')
  String? get extension => throw _privateConstructorUsedError;
  @JsonKey(name: 'snake-case-filename')
  bool? get snakeCaseFilename => throw _privateConstructorUsedError;
  @JsonKey(name: 'filename-getter')
  String? get filenameGetter => throw _privateConstructorUsedError;
  @JsonKey(name: 'out-dir')
  String? get out => throw _privateConstructorUsedError;
  @JsonKey(name: 'target')
  TargetType? get target => throw _privateConstructorUsedError;
  @JsonKey(name: 'generate-type')
  String? get generateFor => throw _privateConstructorUsedError;
  @JsonKey(name: 'output-language')
  String? get outputLanguage => throw _privateConstructorUsedError;
  @JsonKey(name: 'generate-depends')
  List<String>? get depends => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TemplateOutputCopyWith<TemplateOutput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TemplateOutputCopyWith<$Res> {
  factory $TemplateOutputCopyWith(
          TemplateOutput value, $Res Function(TemplateOutput) then) =
      _$TemplateOutputCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'template') String? template,
      @JsonKey(name: 'file-extension') String? extension,
      @JsonKey(name: 'snake-case-filename') bool? snakeCaseFilename,
      @JsonKey(name: 'filename-getter') String? filenameGetter,
      @JsonKey(name: 'out-dir') String? out,
      @JsonKey(name: 'target') TargetType? target,
      @JsonKey(name: 'generate-type') String? generateFor,
      @JsonKey(name: 'output-language') String? outputLanguage,
      @JsonKey(name: 'generate-depends') List<String>? depends});
}

/// @nodoc
class _$TemplateOutputCopyWithImpl<$Res>
    implements $TemplateOutputCopyWith<$Res> {
  _$TemplateOutputCopyWithImpl(this._value, this._then);

  final TemplateOutput _value;
  // ignore: unused_field
  final $Res Function(TemplateOutput) _then;

  @override
  $Res call({
    Object? template = freezed,
    Object? extension = freezed,
    Object? snakeCaseFilename = freezed,
    Object? filenameGetter = freezed,
    Object? out = freezed,
    Object? target = freezed,
    Object? generateFor = freezed,
    Object? outputLanguage = freezed,
    Object? depends = freezed,
  }) {
    return _then(_value.copyWith(
      template: template == freezed
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String?,
      extension: extension == freezed
          ? _value.extension
          : extension // ignore: cast_nullable_to_non_nullable
              as String?,
      snakeCaseFilename: snakeCaseFilename == freezed
          ? _value.snakeCaseFilename
          : snakeCaseFilename // ignore: cast_nullable_to_non_nullable
              as bool?,
      filenameGetter: filenameGetter == freezed
          ? _value.filenameGetter
          : filenameGetter // ignore: cast_nullable_to_non_nullable
              as String?,
      out: out == freezed
          ? _value.out
          : out // ignore: cast_nullable_to_non_nullable
              as String?,
      target: target == freezed
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as TargetType?,
      generateFor: generateFor == freezed
          ? _value.generateFor
          : generateFor // ignore: cast_nullable_to_non_nullable
              as String?,
      outputLanguage: outputLanguage == freezed
          ? _value.outputLanguage
          : outputLanguage // ignore: cast_nullable_to_non_nullable
              as String?,
      depends: depends == freezed
          ? _value.depends
          : depends // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
abstract class _$$_TemplateOutputCopyWith<$Res>
    implements $TemplateOutputCopyWith<$Res> {
  factory _$$_TemplateOutputCopyWith(
          _$_TemplateOutput value, $Res Function(_$_TemplateOutput) then) =
      __$$_TemplateOutputCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'template') String? template,
      @JsonKey(name: 'file-extension') String? extension,
      @JsonKey(name: 'snake-case-filename') bool? snakeCaseFilename,
      @JsonKey(name: 'filename-getter') String? filenameGetter,
      @JsonKey(name: 'out-dir') String? out,
      @JsonKey(name: 'target') TargetType? target,
      @JsonKey(name: 'generate-type') String? generateFor,
      @JsonKey(name: 'output-language') String? outputLanguage,
      @JsonKey(name: 'generate-depends') List<String>? depends});
}

/// @nodoc
class __$$_TemplateOutputCopyWithImpl<$Res>
    extends _$TemplateOutputCopyWithImpl<$Res>
    implements _$$_TemplateOutputCopyWith<$Res> {
  __$$_TemplateOutputCopyWithImpl(
      _$_TemplateOutput _value, $Res Function(_$_TemplateOutput) _then)
      : super(_value, (v) => _then(v as _$_TemplateOutput));

  @override
  _$_TemplateOutput get _value => super._value as _$_TemplateOutput;

  @override
  $Res call({
    Object? template = freezed,
    Object? extension = freezed,
    Object? snakeCaseFilename = freezed,
    Object? filenameGetter = freezed,
    Object? out = freezed,
    Object? target = freezed,
    Object? generateFor = freezed,
    Object? outputLanguage = freezed,
    Object? depends = freezed,
  }) {
    return _then(_$_TemplateOutput(
      template: template == freezed
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String?,
      extension: extension == freezed
          ? _value.extension
          : extension // ignore: cast_nullable_to_non_nullable
              as String?,
      snakeCaseFilename: snakeCaseFilename == freezed
          ? _value.snakeCaseFilename
          : snakeCaseFilename // ignore: cast_nullable_to_non_nullable
              as bool?,
      filenameGetter: filenameGetter == freezed
          ? _value.filenameGetter
          : filenameGetter // ignore: cast_nullable_to_non_nullable
              as String?,
      out: out == freezed
          ? _value.out
          : out // ignore: cast_nullable_to_non_nullable
              as String?,
      target: target == freezed
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as TargetType?,
      generateFor: generateFor == freezed
          ? _value.generateFor
          : generateFor // ignore: cast_nullable_to_non_nullable
              as String?,
      outputLanguage: outputLanguage == freezed
          ? _value.outputLanguage
          : outputLanguage // ignore: cast_nullable_to_non_nullable
              as String?,
      depends: depends == freezed
          ? _value._depends
          : depends // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TemplateOutput implements _TemplateOutput {
  const _$_TemplateOutput(
      {@JsonKey(name: 'template') this.template,
      @JsonKey(name: 'file-extension') this.extension,
      @JsonKey(name: 'snake-case-filename') this.snakeCaseFilename,
      @JsonKey(name: 'filename-getter') this.filenameGetter,
      @JsonKey(name: 'out-dir') this.out,
      @JsonKey(name: 'target') this.target,
      @JsonKey(name: 'generate-type') this.generateFor,
      @JsonKey(name: 'output-language') this.outputLanguage,
      @JsonKey(name: 'generate-depends') final List<String>? depends})
      : _depends = depends;

  factory _$_TemplateOutput.fromJson(Map<String, dynamic> json) =>
      _$$_TemplateOutputFromJson(json);

  @override
  @JsonKey(name: 'template')
  final String? template;
  @override
  @JsonKey(name: 'file-extension')
  final String? extension;
  @override
  @JsonKey(name: 'snake-case-filename')
  final bool? snakeCaseFilename;
  @override
  @JsonKey(name: 'filename-getter')
  final String? filenameGetter;
  @override
  @JsonKey(name: 'out-dir')
  final String? out;
  @override
  @JsonKey(name: 'target')
  final TargetType? target;
  @override
  @JsonKey(name: 'generate-type')
  final String? generateFor;
  @override
  @JsonKey(name: 'output-language')
  final String? outputLanguage;
  final List<String>? _depends;
  @override
  @JsonKey(name: 'generate-depends')
  List<String>? get depends {
    final value = _depends;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'TemplateOutput(template: $template, extension: $extension, snakeCaseFilename: $snakeCaseFilename, filenameGetter: $filenameGetter, out: $out, target: $target, generateFor: $generateFor, outputLanguage: $outputLanguage, depends: $depends)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TemplateOutput &&
            const DeepCollectionEquality().equals(other.template, template) &&
            const DeepCollectionEquality().equals(other.extension, extension) &&
            const DeepCollectionEquality()
                .equals(other.snakeCaseFilename, snakeCaseFilename) &&
            const DeepCollectionEquality()
                .equals(other.filenameGetter, filenameGetter) &&
            const DeepCollectionEquality().equals(other.out, out) &&
            const DeepCollectionEquality().equals(other.target, target) &&
            const DeepCollectionEquality()
                .equals(other.generateFor, generateFor) &&
            const DeepCollectionEquality()
                .equals(other.outputLanguage, outputLanguage) &&
            const DeepCollectionEquality().equals(other._depends, _depends));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(template),
      const DeepCollectionEquality().hash(extension),
      const DeepCollectionEquality().hash(snakeCaseFilename),
      const DeepCollectionEquality().hash(filenameGetter),
      const DeepCollectionEquality().hash(out),
      const DeepCollectionEquality().hash(target),
      const DeepCollectionEquality().hash(generateFor),
      const DeepCollectionEquality().hash(outputLanguage),
      const DeepCollectionEquality().hash(_depends));

  @JsonKey(ignore: true)
  @override
  _$$_TemplateOutputCopyWith<_$_TemplateOutput> get copyWith =>
      __$$_TemplateOutputCopyWithImpl<_$_TemplateOutput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TemplateOutputToJson(
      this,
    );
  }
}

abstract class _TemplateOutput implements TemplateOutput {
  const factory _TemplateOutput(
          {@JsonKey(name: 'template') final String? template,
          @JsonKey(name: 'file-extension') final String? extension,
          @JsonKey(name: 'snake-case-filename') final bool? snakeCaseFilename,
          @JsonKey(name: 'filename-getter') final String? filenameGetter,
          @JsonKey(name: 'out-dir') final String? out,
          @JsonKey(name: 'target') final TargetType? target,
          @JsonKey(name: 'generate-type') final String? generateFor,
          @JsonKey(name: 'output-language') final String? outputLanguage,
          @JsonKey(name: 'generate-depends') final List<String>? depends}) =
      _$_TemplateOutput;

  factory _TemplateOutput.fromJson(Map<String, dynamic> json) =
      _$_TemplateOutput.fromJson;

  @override
  @JsonKey(name: 'template')
  String? get template;
  @override
  @JsonKey(name: 'file-extension')
  String? get extension;
  @override
  @JsonKey(name: 'snake-case-filename')
  bool? get snakeCaseFilename;
  @override
  @JsonKey(name: 'filename-getter')
  String? get filenameGetter;
  @override
  @JsonKey(name: 'out-dir')
  String? get out;
  @override
  @JsonKey(name: 'target')
  TargetType? get target;
  @override
  @JsonKey(name: 'generate-type')
  String? get generateFor;
  @override
  @JsonKey(name: 'output-language')
  String? get outputLanguage;
  @override
  @JsonKey(name: 'generate-depends')
  List<String>? get depends;
  @override
  @JsonKey(ignore: true)
  _$$_TemplateOutputCopyWith<_$_TemplateOutput> get copyWith =>
      throw _privateConstructorUsedError;
}
